// 12_singleton_pattern.cpp
// 싱글톤 : 게임 프로그래밍 패턴중 하나
/*
    싱클톤 패턴
    - 객체의 인스턴스가 *하나*만 존재하는 패턴

*/
#include <iostream>

class Audio {

public:

    //*****
    static Audio& GetInstance() {
        // 지역 변수를 원본으로 리턴하면 안됨.
        static Audio audio; // static으로 선언시 미리 메모리 영역을 지정하여 유지되도록 한다. 
                            //GetInstance()를 여러번 호출 시에도 같은 static audio를 호출함.
        return audio;
    }
    //*****

    void OutSound(std::string music) {
        std::cout << "소리 출력 : " << music << std::endl;
    }

private:
    Audio() = default;                              // 외부에서 기본 생성자 접근 불가
    Audio(const Audio& audio) = delete;             // 기본 제공되는 복사생성자를 제외 시킴. 
    Audio& operator=(const Audio& audio) = delete;  // 기본 제공되는 클래스 대입연산을 제외 시킴.
};

int main() {
    //Audio 생성자가 private : Audio 인스턴스 생성 불가
    //Audio a1;
    //Audio a2;
    
    Audio::GetInstance().OutSound("던전");
    Audio::GetInstance().OutSound("마을");


    return 0;
}








/*
     ** 추가 공부한 개념
    메소드(method) - 함수
    레코드(record) - 구조체, 필드가 두 개 이상 모여 구성한 것
    필드(field) - 구조체를 구성하는 멤버, 데이터를 구성하고 있는 가장 작은단위
*/

/*
    ** 싱글톤(Singleton) 패턴

        개념)
        여러 디자인 패턴 종류 중 하나로, 하나의 클래스에 오직 "1 개의" 객체 인스턴스만 가지는 패턴
            * 디자인 패턴: 프로그램을 설계할때 발생했던 문제점들을 객체 간 상호관계 등을 통해 해결할 수 있도록 하나의 '규약'형태로 만들어 놓은 것.


    ** 싱글톤 패턴 사용 이유

        하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 어디에서든 공유하며 접근, 사용할수 있다.
        싱글톤 패턴으로 만들어진 클래스는 생성자가 여러번 호출 되더라도, 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 보낸다.
        주로 공통된 객체를 여러 개 생성해서 사용하는 DBCP (Database Connection Pool)와 같은 데이터베이스 연결 모듈에 많이 사용된다.


        장점)

    1) 메모리 낭비를 방지
        static(고정된 메모리 영역)을 사용하여 별도의 메모리 영역을 얻으면서 한번의 new 연산자로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할수 있다.

    2) 속도가 빠름
        - 이미 생성된 인스턴스를 활용하기 때문에 속도가 빠르다.

    3) 다른 클래스 간 공유가 쉬움
        - 싱글톤 패턴으로 만들어진 클래스의 인스턴스가 전역 인스턴스기 때문에 다른 클래스의 인스턴스들이 데이터를 공유할 수 있다.
            ex) configration의 설정값인 경우, 객체가 여러개 생성되면 설정값이 변경되어 상이해질 위험이 있는데,
                인스턴스가 1개만 생성되는 싱글톤 패턴을 사용하면 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하도록 할 수 있다.
        - 하지만 여러 클래스의 인스턴스에서 싱글톤 인스턴스의 데이터에 동시에 접근하게 되면 동시성 문제가 발생할 수 있으니 이점을 유의해서 설계하는 것이 좋다.

    4) 인스턴스가 한 개만 존재하는 것을 보증
        - 도메인 관점에서 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우 싱글톤 패턴을 사용하기도 한다.
        인스턴스가 단 하나이기 때문에 인스턴스를 생성할때 드는 비용이 줄어든다.





        단점)

        싱글톤 패턴을 적용하면 위와 같은 효율에서의 이점을 얻을 수 있다. 하지만 싱글톤 패턴이 다음과 같은 많은 문제점들을 수반하기 때문에 trade-off를 잘 고려해야 한다.

        1) 싱글톤 패턴을 구현하는 코드 자체가 많이 필요함
            - 정적 팩토리 메서드(함수)에서 객체 생성을 확인하고 생성자를 호출하는 경우,
              "멀티스레딩 환경"에서 객체가 1개이상 생성되어 오류인 동시성 문제 해결을 위해 syncronized 키워드를 사용해야 한다. (이 외 이를 해결할 수 있는 솔루션이 언어별로 다양하게 있다)


        2) 테스트하기 어렵다
            - 싱글톤 인스턴스는 자원을 "공유" 하고 있기 때문에
              테스트가 결정적으로 격리된 환경에서 수행되려면 "매번" 인스턴스의 상태를 "초기화" 시켜주어야 한다.
              그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 테스트가 온전하게 수행되지 못한다.

        3) 의존 관계상 클라이언트가 구체 클래스에 의존하게 된다. (중요)
            - 싱글톤 인스턴스를 여러곳에서 많이 공유할 경우 다른 클래스의 인스턴스 간 의존성이 높아질 수 있다.
              new 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로,
              이는 SOLID 원칙 중 DIP를 위반하게 되고 OCP 원칙 또한 위반할 가능성이 높다. (객체간의 독립성을 지향하는 객체지향 원칙에 어긋남)

              *** 의존성이 높아지면 수정작업이나 테스트를 진행하기 어려워진다 ***

        4) 자식클래스를 만들수 없다

        5) 내부 상태를 변경하기 어렵다

        (이 외 여러가지 문제들이 존재)

        결과적으로 이러한 문제들을 안고있는 싱글톤 패턴은 유연성이 많이 떨어지는 패턴이라고 할 수 있다.

    결론)

    오직 한 개의 인스턴스 생성을 보증하여 효율을 찾을 수 있지만 그에 못지 않게 수반되는 문제점도 많다.

    싱글톤 패턴은 안티패턴으로 불릴 만큼 단독으로 사용한다면 "객체 지향에 위반"되는 사례가 많다.

    스프링 컨테이너 같은 프레임워크의 도움을 받으면 싱글톤 패턴의 문제점들을 보완하면서 장점의 혜택을 누릴 수 있다.

    실제로 스프링 빈은 컨테이너의 도움을 받아 싱글톤 스콥으로 관리되고 있다.

    프레임워크 도움없이 싱글톤 패턴을 적용하고 싶다면, 위에서 살펴본 장단점의 균현(trade-off)을 잘 고려하여 사용하는 것이 좋을 것이다.
*/


// 싱글톤 패턴을 구현하는 방법은 여러가지가 있다.(아래는 그 중 하나)
// 예제)
// Settings class (Singleton) 

#include <iostream>

class Singleton {

public:

    static Singleton& getIncetance()
    {

        static Singleton s;

        return s;

    }
private:

    Singleton() {}
    Singleton(const Singleton& ref) {}
    Singleton& operator=(const Singleton& ref) {}
    ~Singleton() {}

};

int main()
{
    Singleton& s = Singleton::getIncetance();
    return 0;

}

