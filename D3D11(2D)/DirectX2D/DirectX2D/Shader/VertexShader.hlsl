// 여기서 설명하는 내용은 "그래픽 파이프라인"이라는 개념을 이해해야 함


float4 VS( float4 pos : POSITION ) : SV_POSITION
// 위의 POSITION 등은 시멘틱(sementic)이라고 부름 : 어디에 사용되는 변수인지를 명시하는 것
// 셰이더에서는 반드시 데이터가 어느 것을 받아 어디로 향한다고 명시해야 하는데
// 이를 시멘틱을 통해서 행하는 것

// 추가로 함수 끝부분에 : (sementic)의 형식으로 적었을 경우,
// 본 함수의 반환형에 역시 시멘틱을 할당하는 것

// 이 시멘틱이 왜 필요한지는 메인에서 설명할 예정
{
	return pos;
}
// VS : 정점 셰이더(Vertex Shader)를 처리하는 구문
// 프로그램에서 정점의 데이터를 입력받으면 위와 같이 가공해서
// 다음 그래픽 파이프라인으로 넘기는 코드

// 정점 셰이더에선 입력받은 정점 데이터들을 필요한 형태로 가공해서 다음 단계로 넘기는 역할을 맡음
// 그 과정에선 뷰포트 등, 시점과 관련된 처리를 하게 되어있는데
// 이번 프로그램에서는 관련 처리는 하지 않고(뷰포트가 기본 화면만 보게 되는 특성상 할 필요 없음)
// 받은 정점의 값을 그대로 다음 단계로 넘기는 작업만 함

// 이 VS에서의 작업 결과를 통해 우리는 기존의 3D 공간의 정점 데이터들을
// 화면에 출력하기 위한 좌표로 전환하게 됨

float4 PS() : SV_TARGET
{
	return float4(1.0f, 1.0f, 1.0f, 1.0f);
}
// PS : 픽셀 셰이더(Pixel Shader)를 처리하는 구문
// VS, 테셀레이션, 래스터라이저 등을 통해 처리되어 각 픽셀 단위로 분해된 자료들을 받아
// 모니터의 각 픽셀에 출력할 색을 결정하는 부분

// 이 단계에서 색 보정, 혹은 모자이크 등의 처리도 가능

// 반환형의 시멘틱이 SV_TARGET이라고 되어있는데,
// 이는 이 PS에서 처리가 끝나고 반환되는 값이 SV_TARGET으로 간다 :
// 여기서 나온 결과값이 최종적으로 SV(System Value), 즉 화면에 최종적으로 출력될 값으로서 사용될 것이란 뜻

// 지금 당장은 VS(정점 셰이더), PS(픽셀 셰이더)를 둘 다 한 파일에 몰아서 실행하고 있는데
// 나중에는 각 파일들을 서로 분리시켜서 사용할 예정

// 이 hlsl 파일의 경우
// 1. 사용하기 위해선 확장 -> 확장 관리 -> HLSL Tools for Visual Studio를 설치해야만 제대로 사용 가능
// 2. 파일을 생성한 뒤, 해당 파일을 우클릭->속성으로 들어가서
// HLSL 컴파일러 선택 -> 진입점 이름을 VS(혹은 PS)로 바꿔야 되고
// 셰이더 버전을 반드시 5.0으로 바꿔야 함

// 진입점 : 해당 셰이더 파일을 이용할 때 여기서 정해진 함수로 들어가도록 설정되어 있는 함수
// 이게 속성에서 설정된 이름과 파일 내에서의 함수의 이름과 서로 다르면 에러가 발생함
// 때문에 파일에서 만든 이름과 속성에서의 이름을 일치시켜야 할 필요가 있음
// 나중에 픽셀 셰이더를 다른 파일로 독립시켰을 때는 그 쪽은 VS가 아닌 PS로 지정해야 함

// 셰이더 버젼의 경우, DX11은 5.0부터 호환됨
// 호환되지 않을 경우 기능이 고장나는 경우가 있어 반드시 이를 바꿔줘야 함

// 셰이더 형식의 경우, 실제 용도와 일치하지 않으면 오류가 발생할 여지가 있으니
// 가능한 파일의 실제 용도와 맞춰줘야 함

// 그래서 가끔 이런 에러가 생기는 경우가 있음 :
// "entry point not found" - 속성에 적혀져있는 진입점과 
// 파일 안에 있는 실제 셰이더 처리 함수의 이름이 다른 경우 발생하는 에러
// 가끔 이게 파일의 속성에서 이름을 정확히 바꿔줘도 에러가 발생하는 경우가 있음
// 이런 에러가 발생했을 때는 그냥 hlsl 파일을 프로젝트에서 제외하는 식으로 처리할 것