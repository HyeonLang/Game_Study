struct VertexInput
{
	float4 pos : POSITION;
	float4 color : COLOR;
};
// 지금 보면 이 구조체들 안의 각 멤버에 시멘틱이 포함되어 있음
// 그리고 이 시멘틱들은 VertexShader.cpp에서 정의되었던 레이아웃과 동일함

// -> VS 클래스 쪽에서 데이터가 들어오면 위의 구조체에 들어오게 된다

struct PixelInput
{
	float4 position : SV_Position;
	// 나중에는 이 픽셀 셰이더에서 출력할 점의 좌표를 알아야 되는 경우가 있음
	// 그럴 때 사용하기 위해 만들어진 시멘틱
	// 지금 당장은 위의 VertexInput과 포맷을 맞추기 위해 추가된 것
	float4 color : COLOR;
};

// 위의 두 구조체 : 셰이더에 데이터가 들어왔을 때
// 입력받는 데이터 각각에 이름을 붙여주는 과정

// 이 셰이더라고 하는 것은 DirectX에서 다루는 내용이긴 하지만,
// C++의 문법과 완전히 호환되는 것은 아님
// 따라서 셰이더(HLSL) 고유의 용어에 맞게 구성해줘야 하고,
// 특히 어느 데이터가 추가되는 것인지 셰이터 측에서 알기 어렵기 때문에
// 보내주는 C++ 측에서 데이터의 행선지 및 구조 등을 미리 알려줘야 하는 것
// 그 과정에서 필요한게 위와 같은 입력용 구조체들(포맷)인 것

PixelInput VS(VertexInput input)
{
	PixelInput output;
	output.position = input.pos;
	output.color = input.color;
	
	return output;
	
	// 실질적으로는 값이 달라졌다 하는 건 없음
	// 하지만 서로 다른 구조체, 특히 각 멤버의 시멘틱이 다른 구조체로 변경
	// 이를 통해 픽셀 셰이더에서 처리가 가능한 식으로 데이터가 가공된 것
	
}

float4 PS(PixelInput input) : SV_TARGET
{
	return input.color;
	// 입력받은 색상 데이터를 그대로 출력하는 처리만 함
	// 추가적인 설명은 다음 시간에 진행 예정
	
	// 원래대로라면 PixelInput을 통해 입력받은 데이터들을 통해서
	// 어떤 색으로 처리할 것인지를 연산하고 그 결과를 리턴해야 함
	// 그리고 이 PixelInput에는 색상만 지정된 것이 아닌, 입력받은 정점의 위치까지 같이 기록되어 있음
	// 나중에는 이 위치를 가지고 특정 위치에 있는 정점이면 색을 변화시키는 필터 기능도 만들어볼 예정
	// 이런 필터 기능은 한 달 정도 지나서 만들어볼 것이고
	// 지금 당장은 입력받은 색을 출력시키는 데만 집중할 예정
}
